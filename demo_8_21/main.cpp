#include <iostream>

using namespace std;

//定义一个内联函数
inline myMul(int x = 20, int y = 30)
{
     return x * y;
}

void test01()
{
    cout << "myMul = " << myMul(10+10, 20+20) << endl;
}

//函数的默认参数 指定x的默认值为10，y为20
int myAdd(int x = 10, int y = 20)
{
    return x+y;
}

void test02()
{
    //如果函数传参 那么各自的默认参数将无效
    cout << "myAdd = " << myAdd(100,200) << endl;

    //如果某个参数未被传参 将启用默认值 此时x=100, y 使用默认值20
    cout << "myAdd = " << myAdd(100) << endl;
}


extern int fun01(int x, int y = 25, int z = 35);
void test03()
{
    //如果函数传参 那么各自的默认参数将无效
    cout << "myAdd = " << fun01(100,200) << endl; // 335

    //如果某个参数未被传参 将启用默认值 此时x=100, y 使用默认值20
    cout << "myAdd = " << fun01(100) << endl; // 160
}

void fun02(int x, int y, int)
{
    cout << " x = " << x << " y = " << y << endl;
    return;
}

void test04()
{
    //fun02(1,2,"hello"); // error "hello"和int类型不符合
    fun02(1,2,3);
}

//int main(int argc, char *argv[])
//{
//     //1、宏函数与内联函数
//    /* 宏函数的缺点
//     * 第一个在c中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。
//       第二个问题是c++特有的,预处理器不允许访问类的成员,也就是说预处理器宏不能用作类的成员函数
//     */

//    /*
//     *预处理器宏存在问题的关键是我们可能认为预处理器的行为和编译器的行为是一样的。
//      当然也是由于宏函数调用和函数调用在外表看起来是一样的，因为也容易被混淆。
//      但是其中也会有一些微妙的问题出现:
//         问题一: 无法保证参数的完整性
//         问题二:
//         问题三:预定义宏函数没有作用域概念,无法作为一个类的成员函数,也就是说预定义宏没有办法表示类的范围。
//     */

//    /*
//     * 为了保持预处理宏的效率又增加安全性,而且还能像一般成员函数那样可以在类里访问自如,
//           c++引入了内联函数(inline function).
//       内联函数为了继承宏函数的效率,没有函数调用时开销,然后又可以像普通函数那样,
//          可以进行参数,返回值类型的安全检查,又可以作为成员函数.
//     */

//    /*
//     * 内联函数: 内联函数为了继承函数的效率,没有函数调用时开销,然后又可以像普通函数那样,可以进行参数传递、
//     *           返回值类型的安全检查,又可以作为成员函数。
//     * 内联函数的替换发生在  "编译" 阶段
//     * 内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，
//     * 所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。
//     * 在普通函数(非成员函数)函数前面加上 inline 关键字使之成为内联函数。
//     * 但是必须注意必须函数体和声明结合在一起，否则编译器将它作为普通函数来对待。
//     *
//     * inline void func(int a); 以上写法没有任何效果，仅仅是声明函数，应该如
//       下方式来做: inline int func(int a){return ++;} 注意: 编译器将会检查函数参数列表使
//       用是否正确，并返回值(进行必要的转换)。这些事预处理器无法完成的。
//       内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。
//       我们可以理解为内联函数是以空间换时间。


//        内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函
//        数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。
//     */

//    /* 类内部的内联函数
//     * 为了定义内联函数，通常必须在函数定义前面放一个 inline 关键字。
//     * 但是在类内部定义内联函数时并不是必须的。任何在类内部定义的函数自动成为内联函数
//     */
//        test01();



//    /*2、函数的默认参数(缺省参数)
//     * c++在声明函数原型的时可为一个或者多个参数指定默认(缺省)的参数值,
//     * 当函数调用的时候如果没有传递参数值，编译器会自动用默认值代替。
//     * 注意点:函数的默认参数从左向右，
//     *   1、如果一个参数设置了默认参数，那么这个参数之后的参数都必须设置默认参数。
//         2、(分文件)如果函数声明和函数定义分开写，函数声明和函数定义虽然可以同时设置默认参数,
//                    但建议函数声明处声明函数的默认参数值,因为函数定义处的声明是无效的。
//         3、(同一个文件中)如果函数声明和函数定义分开写，函数声明和函数定义不可以同时设置默认参数,会报错
//                    但建议函数声明处声明函数的默认参数值
//     */
//        test02();
//        test03();

//     /*
//      *3、函数的占位参数
//      *  c++在声明函数时，可以设置占位参数。
//      *  占位参数只有参数类型声明，而没有参数名声明。由于有类型名 所以 函数调用的时候 必须给占位参数传参。
//      *  由于没有形参名, 所以在函数体内部是无法使用占位参数。
//      */
//      test04();

//    return 0;
//}
