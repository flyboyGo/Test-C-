#include <iostream>

using namespace std;

class Plus
{
     private :
         int plus_a;
     public :
         Plus()
         {
             cout << "Plus无参构造函数" << endl;
         }

         Plus(int a)
         {
             plus_a = a;
             cout << "Plus有参构造函数" << endl;
         }

         ~Plus()
         {
             cout << "Plus析构函数" << endl;
         }

};

class Max
{
     private :
         int max_a;
     public :
         Max()
         {
             cout << "Max无参构造函数" << endl;
         }

         Max(int a)
         {
             max_a = a;
             cout << "Max有参构造函数" << endl;
         }

         ~Max()
         {
             cout << "Max析构函数" << endl;
         }

};

class Pro
{
     private :
        Plus ps;   //对象类型成员
        Max mx;    //对象类型成员
        int data; //基本类型成员
     public :
        Pro()
        {
            cout << "Pro的无参构造" << endl;
        }

        Pro(int a, int b, int c):ps(b),mx(c)//初始化列表:对象名+(形参名) 显式调用 调用对象成员的构造函数
        {
            this->data = a;
            //error 无法在Pro类中调用非本类实例化对象的私有属性 可以通过参数初始化列表完成
            //ps.plus_a = b;
            //mx.max_a = c;
            cout << "Pro的有参构造" << endl;
        }

        ~Pro()
        {
            cout << "Pro析构函数" << endl;
        }
};

void test03()
{
    //系统会调用Pro的构造函数(之前 保证 子对象的构造函数先调用)
    //先调用对象成员的无参构造函数 -->再调用自己的无参构造函数 --> 析构自身 -->再析构对象成员
    //Pro p;

    //系统默认调用的是 对象成员的无参构造函数
    //必须在Pro构造函数中 使用初始化列表使其对象成员 调用有参构造函数
    Pro p2(1,2,3);

    //注意
    //1、当调用构造函数时，首先按各对象成员在类定义中的顺序有关（和初始化列表参数的顺序无关）
    //    依次调用它们的构造函数，对这些对象初始化，最后再调用自身的构造函数函数
    //2、也就是说，先调用对象成员的构造函数，再调用本身的构造函数。 析构函数和构造函数调用顺序相反，先构造，后析构。
}

//int main(int argc, char *argv[])
//{
//    //在类中定义的数据成员一般都是基本的数据类型。
//    //但是类中的成员也可以是对象,叫做对象成员。
//    test03();

//    return 0;
//}

/*
 * 在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，
   叫做对象成员。 C++中对对象的初始化是非常重要的操作，当创建一个对象的时
   候，c++编译器必须确保调用了所有子对象的构造函数。如果所有的子对象有默认
   构造函数，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者
   想指定调用某个构造函数怎么办？ 那么是否可以在类的构造函数直接调用子类的
   属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完
   成初始化的。 解决办法非常简单：对于子类调用构造函数，c++为此提供了专门的
   语法，即构造函数初始化列表。 当调用构造函数时，首先按各对象成员在类定义
   中的顺序（和参数初始化列表的顺序无关）依次调用它们的构造函数，对这些对象初始
   化，最后再调用本身的函数体。也就是说，先调用对象成员的构造函数，再调用本
   身的构造函数。 析构函数和构造函数调用顺序相反，先构造，后析构。
 */
