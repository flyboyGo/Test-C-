#include <iostream>

using namespace std;

/*
 * 纯虚析构函数在 c++中是合法的，但是在使用的时候有一个额外的限制：必须为纯
   虚析构函数提供一个函数体。 那么问题是：如果给虚析构函数提供函数体了，那
   怎么还能称作纯虚析构函数呢？ 纯虚析构函数和非纯析构函数之间唯一的不同之
   处在于纯虚析构函数使得基类是抽象类，不能创建基类的对象
 */

//纯虚析构函数：必须实现函数体
class Base
{
public:
    //纯虚析构函数
    //1、virtual修饰 加上 = 0
    virtual ~Base() = 0;
};

//2、必须实现 析构函数的函数体
Base::~Base()
{
    cout << "析构函数" << endl;
}

//原因:通过基类地址 释放子类对象时 先调用子类析构 再父类析构函数(如果父类的析构不实现 无法实现调用)

//虚函数、纯虚函数、虚析构、纯虚析构
/*
 * 1、虚函数：只是virtual修饰有函数体(作用于成员函数)
 *    目的：通过基类指针或引用 操作 子类的方法
 *
 * 2、纯虚函数：virtual修饰 加 = 0 没有函数体 所在类为抽象类
 *    目的：为子类提供固定的流程和接口
 *
 * 3、虚析构：virtual修饰 类中的析构函数
 *    目的：为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象
 *
 * 4、纯虚析构：virtual修饰 加 = 0 必须实现析构的函数体(类外实现)
 *    目的：用基类的指针删除派生类对象、同时提供固定接口
 */

//重载、重写、重定义
/*
 * 重载：同一作用域的 同名函数、参数个数，参数顺序，参数类型不同和 函数返回值没有关系
 *     const也可以作为重载条件 //do(const Teacher& t){} do(Teacher& t)
 *
 * 重定义(隐藏)：有继承 子类(派生类) 重新定义 父类（基类）的 同名成员（非virtual函数）
 *
 * 重写(覆盖 更新虚基类指针指向的虚基类表中虚函数的地址)：有继承 子类（派生类）重写父类（基类）的 virtual函数
              函数返回值，函数名字，函数参数，必须和基类中的虚函数一致
 *
 *
 */

int main(int argc, char *argv[])
{


    return 0;
}


